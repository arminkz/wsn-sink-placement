package misc; //Created by Armin (github.com/arminkz)

import model.SensorNode;
import org.apache.commons.math3.random.HaltonSequenceGenerator;

import graph.Graph;
import graph.Vertex;

import java.awt.*;
import java.io.*;
import java.util.ArrayList;
import java.util.Random;

public class RandomScenarioGenerator {

    public static void main(String[] args) {
        RandomScenarioGenerator.generate("wsn_100",
                4,2,500,500,250,5);
    }

    //Generates a random scenario using WSN wireless range model and writes the result to scenario directory
    //note: sink_types is not generated by this tool and must be added manually or by other means
    public static void generate(String scenario_name, int grid_sensor_count, int grid_sc_count,
                                int cell_width, int cell_height, double wireless_range,
                                int gridSize){

        //TODO: this data should not be hard coded
        String[] possibleSensorStrings = {
                "1,2,0,0,200",
                "1,4,0,0,200",
                "2,3,20,500,300",
                "2,3,30,500,500"
        };

        File directory = new File("data/" + scenario_name);
        File graphFile = new File("data/" + scenario_name + "/graph.csv");
        File sensorsFile = new File("data/" + scenario_name + "/sensors.csv");
        File sinkTypesFile = new File("data/" + scenario_name + "/sink_types.csv");
        File sinksFile = new File("data/" + scenario_name + "/sinks.csv");

        //create files if there are not present
        try {
            if(!directory.exists()) directory.mkdir();
            if(!graphFile.exists()) graphFile.createNewFile();
            if(!sensorsFile.exists()) sensorsFile.createNewFile();
            if(!sinksFile.exists()) sinksFile.createNewFile();
        } catch (IOException e) {
            e.printStackTrace();
        }

        // use Grid to reduce dispersion of placement points
        ArrayList<Point> placmentPoints = new ArrayList<>();
        ArrayList<Vertex> vertices = new ArrayList<>();
        ArrayList<Vertex>[][] grid = new ArrayList[gridSize][gridSize];

        HaltonSequenceGenerator halton2d = new HaltonSequenceGenerator(2);
        Random rnd = new Random(77);

//
        System.out.println("Grid Info: " + grid_sensor_count + " sensors and "
                + grid_sc_count + " sink candidates in each cell.");

        int grid_total_count = grid_sensor_count + grid_sc_count;

        for (int i = 0; i < gridSize; i++) {
            for (int j = 0; j < gridSize; j++) {
                grid[i][j] = new ArrayList<>();
                for (int k = 0; k < grid_total_count; k++) {
                    // create a random point inside grid
                    double[] vec = halton2d.nextVector();
                    int ox = (int)(vec[0] * cell_width);
                    int oy = (int)(vec[1] * cell_height);
                    int px = (cell_width * i) + ox;
                    int py = (cell_height * j) + oy;
                    Point pt = new Point(px,py);
                    // add point to points list
                    placmentPoints.add(pt);
                    Vertex v = new Vertex();
                    v.setPos(pt);
                    vertices.add(v);
                    // add vertex to grid cell
                    grid[i][j].add(v);
                }
            }
        }

        // create graph edges if they are closer than wireless range and write graph to file
        try {
            BufferedWriter wrt = new BufferedWriter(new FileWriter(graphFile));
            //write headers
            wrt.write("start,end,weight\n");
            for (int i = 0; i < placmentPoints.size(); i++) {
                for (int j = i+1; j < placmentPoints.size(); j++) {
                    Point p1 = placmentPoints.get(i);
                    Point p2 = placmentPoints.get(j);
                    double dist = Math.hypot(p2.x-p1.x,p2.y-p1.y);
                    if(dist <= wireless_range) {
                        //create edge and write to file
                        wrt.write(i+","+j+",1"); // use weight 1 for now
                        wrt.newLine();
                        //g.addEdge(g.getVertices().get(i),g.getVertices().get(j),1);
                    }
                }
            }
            wrt.flush();
            wrt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }


        //place sink candidates
        try {
            BufferedWriter wrt = new BufferedWriter(new FileWriter(sinksFile));
            // write headers
            wrt.write("vertex,(posx),(posy)\n");
            for (int i = 0; i < gridSize; i++) {
                for (int j = 0; j < gridSize; j++) {
                    for (int k = 0; k < grid_sc_count; k++) {
                        // choose one random vertex within Grid to act as a SinkCandidate
                        int rIndex = rnd.nextInt(grid[i][j].size());
                        Vertex v = grid[i][j].get(rIndex);
                        int index = vertices.indexOf(v);
                        // remove vertex from grid
                        grid[i][j].remove(rIndex);
                        //place a sink candidate on index
                        wrt.write(String.valueOf(index) + "," + v.getPos().x + "," + v.getPos().y);
                        wrt.newLine();
                    }
                }
            }
            wrt.flush();
            wrt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        //write sensors to file
        try {
            BufferedWriter wrt = new BufferedWriter(new FileWriter(sensorsFile));
            //write headers
            wrt.write("vertex,name,kc,maxl,cpu,ram,bw,(posx),(posy)\n");

            int sensor_name = 1;
            for (int i = 0; i < gridSize; i++) {
                for (int j = 0; j < gridSize; j++) {
                    for(Vertex v: grid[i][j]){
                        // choose one random sensor string
                        String sensorSpec = possibleSensorStrings[rnd.nextInt(possibleSensorStrings.length)];
                        int index = vertices.indexOf(v);
                        Point pos = v.getPos();
                        String sensorStr = index +  "," + sensor_name + "," + sensorSpec + "," + pos.x + "," + pos.y;
                        sensor_name++;
                        wrt.write(sensorStr);
                        wrt.newLine();
                    }
                }
            }
            wrt.flush();
            wrt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("scenario generated successfully!");
    }

    //Generate Example Scenario Using Erdős–Rényi model
    public static Graph erdos(int sensor_count, int sc_count, double p) {
        Graph g = new Graph("erdos");
        int n = sensor_count + sc_count;
        ArrayList<Vertex> vertices = new ArrayList<>();
        Random rnd = new Random();

        //create vertices
        for (int i = 0; i < n; i++) {
            g.addVertex(new Vertex());
        }

        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                double s = rnd.nextDouble();
                if(s < p) {
                    //create edge
                    g.addEdge(g.getVertices().get(i),g.getVertices().get(j),1);
                }
            }
        }

        //place sink candidates
        ArrayList<Integer> possibleSCs = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            possibleSCs.add(i);
        }
        for (int i = 0; i < sc_count; i++) {
            int k = rnd.nextInt(possibleSCs.size());
            int index = possibleSCs.get(k);
            possibleSCs.remove(k);
            //place a sink candidate on index
            //g.getVertices().get(index).setNode();
        }
        //place sensors
        for (int i = 0; i < possibleSCs.size(); i++) {
            int index = possibleSCs.get(i);
            g.getVertices().get(index).setNode(new SensorNode("S"+i,3,3,0,0,0));
        }

        return g;
    }

}
